source: https://cedar-renjun.github.io/2015/12/28/C-and-C-plusplus-pointer-1/

# function pointer

## 一：函数的本质
表达式的抽象，它在内存中对应的数据结构为堆栈帧，它表示一段连续指令序列，这段连续指令序列在内存中有一个确定的起始地址，它执行时一般需要传入参数，执行结束后会返回一个参数。

## 二：函数指针的好处
在处理“在运行时根据数据的具体状态来选择相应的处理方式”这种需求时更加灵活。

## 三：函数指针定义及其原则
形式一定要具备完备性，能表达出我们所要表达的内容。函数类型是靠这几个方面来确定的：
1. 函数的参数个数
2. 函数的参数类型
3. 函数的返回值类型

所以，在 C 语言与 C++ 语言中定义函数指针分别为
```
返回类型 (*函数指针名称)(参数类型,参数类型,参数类型，…);
返回类型 (类名称::*函数成员名称)(参数类型，参数类型，参数类型，….)
```
注意，函数指针名称那儿的括号内容不能少，因为少了的话就有歧义性了。

concret example:

```c++
int (*pFunction)(float,char,char)=NULL;
int (MyClass::*pMemberFunction)(float,char,char)=NULL;
int (MyClass::*pConstMemberFunction)(float,char,char) const=NULL;
```

## 四：伏笔：函数的调用规则

## 五：函数指针的赋值、使用
### 在 C 中以及 C++ 的静态函数使用是一样的
赋值都可以用
```
pFunction=func1;
pFunction=&func2;
```
因为函数指针不具有二义性，即普通指针中，我们不知道其指向的是变量本身还是变量的地址。但是为了与普通变量的统一性，在写代码的时候一般还是要添加 &。

而在 C++ 中使用函数指针要稍微复杂一点，必须添加取地址符号 &。(这一点这篇博客中的说法自相矛盾，带考究) (后续：经实验发现就是后面的这种，也挺合理的)
```c++
MyClass mc;
pMemberFunction= &MyClass::func1;  //必须要加取地址符号
pConstMemberFunction = &mc.func2;
```
类中的静态函数，定义与普通函数一样，不需要加类的限定符。